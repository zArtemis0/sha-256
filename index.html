<!DOCTYPE html>
<html>
<head>
  <title>Real SHA-256 Miner</title>
  <style>
    body { background:#0d1117; color:#c9d1d9; font-family:monospace; }
    h1 { color:#58a6ff; }
    button { background:#21262d; border:1px solid #30363d; color:#c9d1d9; padding:6px 12px; margin:5px; cursor:pointer; }
    button:hover { background:#30363d; }
    #hps { margin-top:5px; color:#4fd1ff; }
  </style>
</head>
<body>
  <h1>Real-System Miner</h1>
  <div id="gen">Generation: 0</div>
  <div id="input">Current Input: —</div>
  <div id="hash">Lowest Hash: —</div>
  <div id="hps">Hashes/sec: —</div>
  
  <button onclick="startMiner()">Start</button>
  <button onclick="stopMiner()">Stop</button>

<script>
// --- Random hex generator ---
function cryptoRandomHex(len) {
  const arr = new Uint8Array(len / 2);
  crypto.getRandomValues(arr);
  return Array.from(arr).map(b => b.toString(16).padStart(2, "0")).join("");
}

// --- Fake but realistic Bitcoin-like block header ---
function fakeBlockHeader(counter) {
  const version = "20000000"; // version
  const prevHash = cryptoRandomHex(64); // prev block hash
  const merkleRoot = cryptoRandomHex(64); // merkle root
  const timestamp = Math.floor(Date.now() / 1000).toString(16).padStart(8,"0");
  const bits = "1d00ffff"; // difficulty (testnet style)
  const nonce = counter.toString(16).padStart(8,"0"); // increments
  return version + prevHash + merkleRoot + timestamp + bits + nonce;
}

let running = false;
let generation = 0;
let lowestHash = null;
let counter = 0;
let loop;
let hashCount = 0;
let lastTime = performance.now();

async function sha256hex(str) {
  const buf = new TextEncoder().encode(str);
  const hash = await crypto.subtle.digest("SHA-256", buf);
  return Array.from(new Uint8Array(hash))
    .map(b => b.toString(16).padStart(2,"0")).join("");
}

async function mineBatch() {
  const batchSize = 200;
  for (let i=0; i<batchSize; i++) {
    const input = fakeBlockHeader(counter++);
    const hash = await sha256hex(input);

    if (!lowestHash || hash < lowestHash) {
      lowestHash = hash;
      document.getElementById("hash").innerText = "Lowest Hash: " + lowestHash;
      document.getElementById("input").innerText = "Current Input: " + input;
    }
    generation++;
    hashCount++;
  }

  document.getElementById("gen").innerText = "Generation: " + generation;

  // Update hashes/sec every second
  const now = performance.now();
  if (now - lastTime >= 1000) {
    document.getElementById("hps").innerText = "Hashes/sec: " + hashCount.toLocaleString();
    hashCount = 0;
    lastTime = now;
  }

  if (running) {
    loop = requestAnimationFrame(mineBatch);
  }
}

function startMiner() {
  if (!running) {
    running = true;
    loop = requestAnimationFrame(mineBatch);
  }
}

function stopMiner() {
  running = false;
  cancelAnimationFrame(loop);
}
</script>
</body>
</html>
