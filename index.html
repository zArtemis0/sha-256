<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Real SHA-256 Miner (Browser)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
         background:#0b0b0b; color:#e6ffe6; margin:0; padding:24px; }
  h1 { margin:0 0 16px; color:#7fffd4; }
  .grid { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
  .card { background:#111; border:1px solid #1f1f1f; border-radius:12px; padding:14px; }
  .row { display:flex; justify-content:space-between; gap:12px; margin:6px 0; }
  .mono { font-family: inherit; word-break: break-all; }
  label { font-size: 14px; opacity:.9 }
  input[type="number"] { width:110px; padding:6px 8px; border-radius:8px; border:1px solid #333; background:#0e0e0e; color:#e6ffe6; }
  button { padding:10px 14px; border-radius:10px; border:1px solid #2a2a2a; background:#0e1310; color:#b9ffd1; cursor:pointer; }
  button:hover { background:#0f1a15; }
  .muted { opacity:.75 }
  .ok { color:#a9ffb6 }
  .warn { color:#ffd27f }
  .err { color:#ff9f9f }
  .big { font-size: 18px; }
</style>
</head>
<body>

<h1>Real SHA-256 Miner (Browser)</h1>

<div class="grid">
  <div class="card">
    <div class="row"><span>Generation</span><span id="generation" class="big">0</span></div>
    <div class="row"><span>Current Input</span><span id="currentInput" class="mono">—</span></div>
    <div class="row"><span>Lowest Hash</span><span id="lowestHash" class="mono">—</span></div>
    <div class="row"><span>Input for Lowest Hash</span><span id="lowestInput" class="mono">—</span></div>
  </div>

  <div class="card">
    <div class="row"><span>Hashes / sec</span><span id="hps">—</span></div>
    <div class="row"><span>CPU Cores</span><span id="cpuCores">—</span></div>
    <div class="row"><span>RAM Used (JS heap)</span><span id="ramUsed">—</span></div>
    <div class="row"><span>Secure Context</span><span id="secure" class="mono">—</span></div>
  </div>
</div>

<div class="card" style="margin-top:12px">
  <div class="row">
    <label for="batch">Batch size (hashes per worker round)</label>
    <input id="batch" type="number" min="1" step="1" value="256" />
  </div>
  <div class="row">
    <div>
      <button id="startBtn">Start</button>
      <button id="stopBtn">Stop</button>
    </div>
    <div class="muted">Tip: start small (128–512). Larger batch = higher throughput, more latency on updates.</div>
  </div>
  <div id="note" class="muted" style="margin-top:8px"></div>
</div>

<script>
/* ---------- DOM refs ---------- */
const el = (id)=>document.getElementById(id);
const generationEl = el('generation');
const currentInputEl = el('currentInput');
const lowestHashEl = el('lowestHash');
const lowestInputEl = el('lowestInput');
const hpsEl = el('hps');
const cpuCoresEl = el('cpuCores');
const ramUsedEl = el('ramUsed');
const secureEl = el('secure');
const startBtn = el('startBtn');
const stopBtn = el('stopBtn');
const batchInput = el('batch');
const noteEl = el('note');

/* ---------- System info ---------- */
cpuCoresEl.textContent = navigator.hardwareConcurrency ?? '—';
secureEl.textContent = (window.isSecureContext ? 'yes' : 'no') + (window.isSecureContext ? '' : ' (serve via https:// or http://localhost)');
secureEl.className = window.isSecureContext ? 'ok' : 'warn mono';

/* ---------- Worker (inline via Blob) ---------- */
const workerSrc = `
let running = false;
let counter = 1;
let generation = 0;
let lowestHash = null;
let lowestInput = null;
let batchSize = 256;
const enc = new TextEncoder();

function toHex(buf){
  const v = new Uint8Array(buf);
  let s = '';
  for(let i=0;i<v.length;i++){ const b=v[i].toString(16).padStart(2,'0'); s += b; }
  return s;
}

async function mineRound(){
  const t0 = performance.now();
  const inputs = new Array(batchSize);
  for(let i=0;i<batchSize;i++){ inputs[i] = 'input_' + (counter++); }
  // Hash all inputs in parallel
  const promises = inputs.map(str => crypto.subtle.digest('SHA-256', enc.encode(str)));
  const results = await Promise.all(promises);
  for(let i=0;i<results.length;i++){
    const hex = toHex(results[i]);
    if(!lowestHash || hex < lowestHash){ lowestHash = hex; lowestInput = inputs[i]; }
  }
  generation += batchSize;
  const t1 = performance.now();
  const hps = batchSize / ((t1 - t0)/1000);
  postMessage({
    type:'progress',
    generation,
    currentInput: inputs[inputs.length-1],
    lowestHash,
    lowestInput,
    hps
  });
}

async function loop(){
  while(running){
    try{
      await mineRound();
    }catch(err){
      postMessage({ type:'error', message: String(err) });
      running = false;
      break;
    }
    // yield to event loop
    await new Promise(requestAnimationFrame);
  }
}

onmessage = (ev)=>{
  const { cmd } = ev.data || {};
  if(cmd === 'start'){
    batchSize = Math.max(1, ev.data.batchSize|0);
    if(!self.crypto || !crypto.subtle){
      postMessage({ type:'error', message: 'SubtleCrypto not available. Use HTTPS or localhost.' });
      return;
    }
    if(running) return;
    running = true;
    loop();
  }else if(cmd === 'stop'){
    running = false;
  }else if(cmd === 'setBatch'){
    batchSize = Math.max(1, ev.data.batchSize|0);
  }else if(cmd === 'reset'){
    counter = 1; generation = 0; lowestHash = null; lowestInput = null;
  }
};
`;
const worker = new Worker(URL.createObjectURL(new Blob([workerSrc], {type:'text/javascript'})));

/* ---------- UI state & wiring ---------- */
let latest = {
  generation: 0,
  currentInput: '—',
  lowestHash: '—',
  lowestInput: '—',
  hps: 0
};

function refreshUI(){
  generationEl.textContent = latest.generation.toLocaleString();
  currentInputEl.textContent = latest.currentInput;
  lowestHashEl.textContent = latest.lowestHash || '—';
  lowestInputEl.textContent = latest.lowestInput || '—';
  hpsEl.textContent = latest.hps ? Math.round(latest.hps).toLocaleString() + ' h/s' : '—';

  // RAM used (Chromium only)
  if (performance.memory){
    const mb = performance.memory.usedJSHeapSize / 1048576;
    ramUsedEl.textContent = Math.floor(mb).toLocaleString() + ' MB';
  } else {
    ramUsedEl.textContent = '—';
  }
  requestAnimationFrame(refreshUI);
}
refreshUI();

worker.onmessage = (ev)=>{
  const msg = ev.data;
  if(msg.type === 'progress'){
    latest.generation = msg.generation;
    latest.currentInput = msg.currentInput;
    latest.lowestHash = msg.lowestHash;
    latest.lowestInput = msg.lowestInput;
    latest.hps = msg.hps;
  }else if(msg.type === 'error'){
    noteEl.innerHTML = '<span class="err">Error: ' + msg.message + '</span>';
  }
};

startBtn.onclick = ()=>{
  const bs = parseInt(batchInput.value, 10);
  noteEl.textContent = '';
  worker.postMessage({ cmd:'setBatch', batchSize: bs });
  worker.postMessage({ cmd:'start', batchSize: bs });
};
stopBtn.onclick = ()=>{
  worker.postMessage({ cmd:'stop' });
};

/* Helpful reminder if not secure */
if(!window.isSecureContext){
  noteEl.innerHTML = '<span class="warn">This must be served via HTTPS or http://localhost for crypto.subtle.digest to work.</span>';
}
</script>
</body>
</html>
