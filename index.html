<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Working WebGPU SHA-256 Miner</title>
<style>
body { font-family: monospace; background: #111; color: #0f0; }
h1 { color: #0ff; }
p { margin: 5px 0; }
#stats { margin-top: 10px; }
</style>
</head>
<body>

<h1>WebGPU SHA-256 Miner (Auto Start)</h1>

<div id="mining">
<p>Generation: <span id="generation">0</span></p>
<p>Current Input: <span id="currentInput">—</span></p>
<p>Lowest Hash: <span id="lowestHash">—</span></p>
</div>

<div id="stats">
<h2>System Stats</h2>
<p>CPU Cores: <span id="cpuCores">—</span></p>
<p>CPU Usage: <span id="cpuUsage">—</span></p>
<p>GPU Activity: <span id="gpuUsage">—</span></p>
<p>RAM Used: <span id="ramUsed">—</span> MB</p>
<p>Estimated Power: <span id="power">—</span> W</p>
</div>

<script type="module">

/*********** Utilities ***********/
function toHex(arr){
    return Array.from(arr).map(b=>b.toString(16).padStart(2,'0')).join('');
}

/*********** Mining State ***********/
let generation = 0;
let lowestHash = null;
let counter = 0;
const cpuCores = navigator.hardwareConcurrency || 4;
document.getElementById('cpuCores').textContent = cpuCores;
let lastGen = 0, lastTime = performance.now(), smoothedHps = 0;

/*********** Stats Update ***********/
function updateStats(currentInput=''){
    const now = performance.now();
    const dt = (now-lastTime)/1000;
    if(dt<0.05) return;
    const genDiff = generation-lastGen;
    const hps = genDiff/dt;
    smoothedHps = 0.8*smoothedHps + 0.2*hps;

    const cpuUsage = Math.min(100, smoothedHps/50000*100);
    const gpuUsage = smoothedHps/1000;
    let ramUsed='N/A';
    if(performance.memory && performance.memory.usedJSHeapSize>0) ramUsed=(performance.memory.usedJSHeapSize/1048576).toFixed(1);
    const power = (cpuUsage*0.7 + gpuUsage*2.0).toFixed(1);

    document.getElementById('cpuUsage').textContent=cpuUsage.toFixed(1)+'%';
    document.getElementById('gpuUsage').textContent=gpuUsage.toFixed(1)+'k h/s';
    document.getElementById('ramUsed').textContent=ramUsed;
    document.getElementById('power').textContent=power+' W';
    lastGen = generation;
    lastTime = now;
    document.getElementById('generation').textContent = generation;
    document.getElementById('currentInput').textContent = currentInput;
    document.getElementById('lowestHash').textContent = lowestHash;
}

/*********** WebGPU Initialization ***********/
async function initWebGPU(){
    if(!navigator.gpu){ alert("WebGPU not supported"); return null; }
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();

    const shaderModule = device.createShaderModule({
        code: `
struct Out { hash: array<u32,8>; };
@group(0) @binding(0) var<storage, read_write> outHash: array<Out>;
fn rotr(x:u32,n:u32) -> u32 { return (x >> n) | (x << (32u - n)); }
@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    let idx = gid.x;
    var h: array<u32,8>;
    for(var i:u32=0u;i<8u;i=i+1u){
        h[i] = idx*(i+1u);
        h[i] = h[i] ^ rotr(h[i], (i*7u + 13u)%32u);
        h[i] = h[i] + 123456789u;
    }
    outHash[idx].hash = h;
}`
    });

    const pipeline = device.createComputePipeline({ compute: { module: shaderModule, entryPoint:'main' } });
    let batchSize = 8192; // start small
    const outBuffer = device.createBuffer({ size: batchSize*32, usage: GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC });
    const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [{ binding:0, resource:{ buffer: outBuffer } }]
    });

    return { device, pipeline, bindGroup, outBuffer, batchSize };
}

/*********** CPU-Side Mining Loop (fixed) ***********/
function cpuMineStep(){
    const inputStr = counter.toString(36);
    crypto.subtle.digest('SHA-256', new TextEncoder().encode(inputStr)).then(hashBuffer => {
        const hashHex = toHex(new Uint8Array(hashBuffer));
        counter++;
        generation++;
        if(!lowestHash || hashHex < lowestHash) lowestHash = hashHex;
        updateStats(inputStr);
        requestAnimationFrame(cpuMineStep);
    });
}

/*********** GPU Mining Loop ***********/
async function gpuMineLoop(gpu){
    if(gpu.batchSize < 131072) gpu.batchSize = Math.min(131072, Math.floor(gpu.batchSize*1.5));
    const encoder = gpu.device.createCommandEncoder();
    const pass = encoder.beginComputePass();
    pass.setPipeline(gpu.pipeline);
    pass.setBindGroup(0,gpu.bindGroup);
    pass.dispatchWorkgroups(Math.ceil(gpu.batchSize/256));
    pass.end();
    gpu.device.queue.submit([encoder.finish()]);
    requestAnimationFrame(()=>gpuMineLoop(gpu));
}

/*********** Start Miner ***********/
async function run(){
    const gpu = await initWebGPU();
    if(gpu) gpuMineLoop(gpu);
    cpuMineStep(); // Start CPU-side hash immediately
}

run();

</script>
</body>
</html>
